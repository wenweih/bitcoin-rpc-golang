// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package proto

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto(in *jlexer.Lexer, out *Vout) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "value":
			out.Value = float64(in.Float64())
		case "n":
			out.N = uint32(in.Uint32())
		case "scriptPubKey":
			if in.IsNull() {
				in.Skip()
				out.ScriptPubKey = nil
			} else {
				if out.ScriptPubKey == nil {
					out.ScriptPubKey = new(ScriptPubKey)
				}
				(*out.ScriptPubKey).UnmarshalEasyJSON(in)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto(out *jwriter.Writer, in Vout) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Value != 0 {
		const prefix string = ",\"value\":"
		first = false
		out.RawString(prefix[1:])
		out.Float64(float64(in.Value))
	}
	if in.N != 0 {
		const prefix string = ",\"n\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint32(uint32(in.N))
	}
	if in.ScriptPubKey != nil {
		const prefix string = ",\"scriptPubKey\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(*in.ScriptPubKey).MarshalEasyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Vout) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Vout) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Vout) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Vout) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto(l, v)
}
func easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto1(in *jlexer.Lexer, out *Vin) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "txid":
			out.Txid = string(in.String())
		case "vout":
			out.Vout = uint32(in.Uint32())
		case "coinbase":
			out.Coinbase = string(in.String())
		case "scriptSig":
			if in.IsNull() {
				in.Skip()
				out.ScriptSig = nil
			} else {
				if out.ScriptSig == nil {
					out.ScriptSig = new(ScriptSig)
				}
				(*out.ScriptSig).UnmarshalEasyJSON(in)
			}
		case "txinwitness":
			if in.IsNull() {
				in.Skip()
				out.Txinwitness = nil
			} else {
				in.Delim('[')
				if out.Txinwitness == nil {
					if !in.IsDelim(']') {
						out.Txinwitness = make([]string, 0, 4)
					} else {
						out.Txinwitness = []string{}
					}
				} else {
					out.Txinwitness = (out.Txinwitness)[:0]
				}
				for !in.IsDelim(']') {
					var v1 string
					v1 = string(in.String())
					out.Txinwitness = append(out.Txinwitness, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "sequence":
			out.Sequence = uint32(in.Uint32())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto1(out *jwriter.Writer, in Vin) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Txid != "" {
		const prefix string = ",\"txid\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Txid))
	}
	if in.Vout != 0 {
		const prefix string = ",\"vout\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint32(uint32(in.Vout))
	}
	if in.Coinbase != "" {
		const prefix string = ",\"coinbase\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Coinbase))
	}
	if in.ScriptSig != nil {
		const prefix string = ",\"scriptSig\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(*in.ScriptSig).MarshalEasyJSON(out)
	}
	if len(in.Txinwitness) != 0 {
		const prefix string = ",\"txinwitness\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v2, v3 := range in.Txinwitness {
				if v2 > 0 {
					out.RawByte(',')
				}
				out.String(string(v3))
			}
			out.RawByte(']')
		}
	}
	if in.Sequence != 0 {
		const prefix string = ",\"sequence\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint32(uint32(in.Sequence))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Vin) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Vin) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Vin) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Vin) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto1(l, v)
}
func easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto2(in *jlexer.Lexer, out *Transaction) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "txid":
			out.Txid = string(in.String())
		case "hash":
			out.Hash = string(in.String())
		case "version":
			out.Version = int32(in.Int32())
		case "size":
			out.Size = int32(in.Int32())
		case "vsize":
			out.Vsize = int32(in.Int32())
		case "weight":
			out.Weight = int32(in.Int32())
		case "locktime":
			out.Locktime = uint32(in.Uint32())
		case "vin":
			if in.IsNull() {
				in.Skip()
				out.Vin = nil
			} else {
				in.Delim('[')
				if out.Vin == nil {
					if !in.IsDelim(']') {
						out.Vin = make([]*Vin, 0, 8)
					} else {
						out.Vin = []*Vin{}
					}
				} else {
					out.Vin = (out.Vin)[:0]
				}
				for !in.IsDelim(']') {
					var v4 *Vin
					if in.IsNull() {
						in.Skip()
						v4 = nil
					} else {
						if v4 == nil {
							v4 = new(Vin)
						}
						(*v4).UnmarshalEasyJSON(in)
					}
					out.Vin = append(out.Vin, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "vout":
			if in.IsNull() {
				in.Skip()
				out.Vout = nil
			} else {
				in.Delim('[')
				if out.Vout == nil {
					if !in.IsDelim(']') {
						out.Vout = make([]*Vout, 0, 8)
					} else {
						out.Vout = []*Vout{}
					}
				} else {
					out.Vout = (out.Vout)[:0]
				}
				for !in.IsDelim(']') {
					var v5 *Vout
					if in.IsNull() {
						in.Skip()
						v5 = nil
					} else {
						if v5 == nil {
							v5 = new(Vout)
						}
						(*v5).UnmarshalEasyJSON(in)
					}
					out.Vout = append(out.Vout, v5)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "hex":
			out.Hex = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto2(out *jwriter.Writer, in Transaction) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Txid != "" {
		const prefix string = ",\"txid\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Txid))
	}
	if in.Hash != "" {
		const prefix string = ",\"hash\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Hash))
	}
	if in.Version != 0 {
		const prefix string = ",\"version\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Version))
	}
	if in.Size != 0 {
		const prefix string = ",\"size\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Size))
	}
	if in.Vsize != 0 {
		const prefix string = ",\"vsize\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Vsize))
	}
	if in.Weight != 0 {
		const prefix string = ",\"weight\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Weight))
	}
	if in.Locktime != 0 {
		const prefix string = ",\"locktime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint32(uint32(in.Locktime))
	}
	if len(in.Vin) != 0 {
		const prefix string = ",\"vin\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v6, v7 := range in.Vin {
				if v6 > 0 {
					out.RawByte(',')
				}
				if v7 == nil {
					out.RawString("null")
				} else {
					(*v7).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	if len(in.Vout) != 0 {
		const prefix string = ",\"vout\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v8, v9 := range in.Vout {
				if v8 > 0 {
					out.RawByte(',')
				}
				if v9 == nil {
					out.RawString("null")
				} else {
					(*v9).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	if in.Hex != "" {
		const prefix string = ",\"hex\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Hex))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Transaction) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Transaction) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Transaction) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Transaction) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto2(l, v)
}
func easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto3(in *jlexer.Lexer, out *ScriptSig) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "asm":
			out.Asm = string(in.String())
		case "hex":
			out.Hex = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto3(out *jwriter.Writer, in ScriptSig) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Asm != "" {
		const prefix string = ",\"asm\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Asm))
	}
	if in.Hex != "" {
		const prefix string = ",\"hex\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Hex))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v ScriptSig) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ScriptSig) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ScriptSig) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto3(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ScriptSig) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto3(l, v)
}
func easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto4(in *jlexer.Lexer, out *ScriptPubKey) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "asm":
			out.Asm = string(in.String())
		case "hex":
			out.Hex = string(in.String())
		case "reqSigs":
			out.ReqSigs = int32(in.Int32())
		case "type":
			out.Type = string(in.String())
		case "addresses":
			if in.IsNull() {
				in.Skip()
				out.Addresses = nil
			} else {
				in.Delim('[')
				if out.Addresses == nil {
					if !in.IsDelim(']') {
						out.Addresses = make([]string, 0, 4)
					} else {
						out.Addresses = []string{}
					}
				} else {
					out.Addresses = (out.Addresses)[:0]
				}
				for !in.IsDelim(']') {
					var v10 string
					v10 = string(in.String())
					out.Addresses = append(out.Addresses, v10)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto4(out *jwriter.Writer, in ScriptPubKey) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Asm != "" {
		const prefix string = ",\"asm\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Asm))
	}
	if in.Hex != "" {
		const prefix string = ",\"hex\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Hex))
	}
	if in.ReqSigs != 0 {
		const prefix string = ",\"reqSigs\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.ReqSigs))
	}
	if in.Type != "" {
		const prefix string = ",\"type\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Type))
	}
	if len(in.Addresses) != 0 {
		const prefix string = ",\"addresses\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v11, v12 := range in.Addresses {
				if v11 > 0 {
					out.RawByte(',')
				}
				out.String(string(v12))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v ScriptPubKey) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto4(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ScriptPubKey) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto4(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ScriptPubKey) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto4(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ScriptPubKey) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto4(l, v)
}
func easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto5(in *jlexer.Lexer, out *GetBlockVerboseTxResult) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "hash":
			out.Hash = string(in.String())
		case "confirmations":
			out.Confirmations = int64(in.Int64())
		case "strippedsize":
			out.Strippedsize = int32(in.Int32())
		case "size":
			out.Size = int32(in.Int32())
		case "weight":
			out.Weight = int32(in.Int32())
		case "height":
			out.Height = int32(in.Int32())
		case "version":
			out.Version = int32(in.Int32())
		case "versionHex":
			out.VersionHex = string(in.String())
		case "merkleroot":
			out.Merkleroot = string(in.String())
		case "tx":
			if in.IsNull() {
				in.Skip()
				out.Tx = nil
			} else {
				in.Delim('[')
				if out.Tx == nil {
					if !in.IsDelim(']') {
						out.Tx = make([]*Transaction, 0, 8)
					} else {
						out.Tx = []*Transaction{}
					}
				} else {
					out.Tx = (out.Tx)[:0]
				}
				for !in.IsDelim(']') {
					var v13 *Transaction
					if in.IsNull() {
						in.Skip()
						v13 = nil
					} else {
						if v13 == nil {
							v13 = new(Transaction)
						}
						(*v13).UnmarshalEasyJSON(in)
					}
					out.Tx = append(out.Tx, v13)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "time":
			out.Time = int64(in.Int64())
		case "mediantime":
			out.Mediantime = int64(in.Int64())
		case "nonce":
			out.Nonce = uint32(in.Uint32())
		case "bits":
			out.Bits = string(in.String())
		case "difficulty":
			out.Difficulty = float64(in.Float64())
		case "chainwork":
			out.Chainwork = string(in.String())
		case "nTx":
			out.NTx = int32(in.Int32())
		case "previousblockhash":
			out.Previousblockhash = string(in.String())
		case "nextblockhash":
			out.Nextblockhash = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto5(out *jwriter.Writer, in GetBlockVerboseTxResult) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Hash != "" {
		const prefix string = ",\"hash\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Hash))
	}
	if in.Confirmations != 0 {
		const prefix string = ",\"confirmations\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Confirmations))
	}
	if in.Strippedsize != 0 {
		const prefix string = ",\"strippedsize\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Strippedsize))
	}
	if in.Size != 0 {
		const prefix string = ",\"size\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Size))
	}
	if in.Weight != 0 {
		const prefix string = ",\"weight\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Weight))
	}
	if in.Height != 0 {
		const prefix string = ",\"height\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Height))
	}
	if in.Version != 0 {
		const prefix string = ",\"version\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.Version))
	}
	if in.VersionHex != "" {
		const prefix string = ",\"versionHex\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.VersionHex))
	}
	if in.Merkleroot != "" {
		const prefix string = ",\"merkleroot\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Merkleroot))
	}
	if len(in.Tx) != 0 {
		const prefix string = ",\"tx\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v14, v15 := range in.Tx {
				if v14 > 0 {
					out.RawByte(',')
				}
				if v15 == nil {
					out.RawString("null")
				} else {
					(*v15).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	if in.Time != 0 {
		const prefix string = ",\"time\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Time))
	}
	if in.Mediantime != 0 {
		const prefix string = ",\"mediantime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Mediantime))
	}
	if in.Nonce != 0 {
		const prefix string = ",\"nonce\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Uint32(uint32(in.Nonce))
	}
	if in.Bits != "" {
		const prefix string = ",\"bits\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Bits))
	}
	if in.Difficulty != 0 {
		const prefix string = ",\"difficulty\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.Difficulty))
	}
	if in.Chainwork != "" {
		const prefix string = ",\"chainwork\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Chainwork))
	}
	if in.NTx != 0 {
		const prefix string = ",\"nTx\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int32(int32(in.NTx))
	}
	if in.Previousblockhash != "" {
		const prefix string = ",\"previousblockhash\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Previousblockhash))
	}
	if in.Nextblockhash != "" {
		const prefix string = ",\"nextblockhash\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Nextblockhash))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v GetBlockVerboseTxResult) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto5(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v GetBlockVerboseTxResult) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBaba02c5EncodeGithubComWenweihBitcoinRpcGolangProto5(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GetBlockVerboseTxResult) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto5(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *GetBlockVerboseTxResult) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBaba02c5DecodeGithubComWenweihBitcoinRpcGolangProto5(l, v)
}
